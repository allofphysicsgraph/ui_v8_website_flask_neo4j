#!/usr/bin/env python3

# Physics Derivation Graph
# Ben Payne, 2021
# https://creativecommons.org/licenses/by/4.0/
# Attribution 4.0 International (CC BY 4.0)

"""
The purpose of this file is to generate .tex files from expressions
"""

import random
import re
import os
import glob
import time

# move and copy files
import shutil
from subprocess import PIPE  # https://docs.python.org/3/library/subprocess.html
import subprocess  # https://stackoverflow.com/questions/39187886/what-is-the-difference-between-subprocess-popen-and-subprocess-run/39187984

# https://docs.python.org/3/library/typing.html
# from typing import Tuple, TextIO, List  # mypy
# TextIO is file handle assocaited with `open()`
from typing import TextIO

import compute
import neo4j_query

proc_timeout = 30


def make_string_safe_for_latex(unsafe_str: str) -> str:
    """
    latex characters that require an escape for printing:
    # $ % & \ ^ _ { }
    TODO: I'm not escaping all of these

    Args:
        unsafe_str: strings that may cause Latex compilation to fail, e.g., "a_string" or "url#subsection"
    Returns:
        safe_str: a string that latex should be able to print, e.g., "a\_string" or "url\#subsection"
    """
    # some derivation notes have valid underscores, like
    # \cite{yyyy_author}
    # while some underscores are invalid latex, like
    # https://en.wikipedia.org/wiki/Equations_of_motion
    # --> Remove citations
    # problem: using
    # re.sub(r'cite{.*}', '', some_text)
    # on the string
    # some_text = "an example cite{2222_asdf} and http://asdf_fagaaf and cite{9492_942} of http:/ss_asdf and more"
    # is greedy
    # to use a non-greedy search; https://stackoverflow.com/a/2503438/1164295
    # unsafe_str_without_citations = re.sub(r"cite{.*?}", "", unsafe_str)

    # replace the first _ that occurs within citation with another string
    unsafe_str_replaced_cite = re.sub(
        r"cite{(.*?)_(.*?)}", "cite{\\1NONSTANDARDUNDRSCR\\2}", unsafe_str
    )
    # that approach breaks when cite has more than one underscore, for example
    # \cite{yyyy_author1_author2}
    unsafe_str_replaced_cite = re.sub(
        r"cite{(.*?)_(.*?)}", "cite{\\1NONSTANDARDUNDRSCR\\2}", unsafe_str_replaced_cite
    )

    safe_str = unsafe_str_replaced_cite.replace("_", "\_").replace("%", "\%")

    fixed_underscore_str = safe_str.replace("NONSTANDARDUNDRSCR", "_")

    no_hashtag_str = (
        fixed_underscore_str.replace("#", "\#").replace("$", "\$").replace("%", "\%")
    )

    return no_hashtag_str


def generate_tex_file_for_derivation(
    graphDB_Driver, query_time_dict: dict, derivation_id: str, path_to_tex_file: str
) -> str:
    """
    In v7 the PDG I started allowing inference rule names
    to have spaces. (In versions prior to 7 the inference rule names were
    camel case.) When I implemented this function in v7 I learned why the
    inference rule names had been camel case: Latex does not like
    newcommand names to have underscore in them; see https://tex.stackexchange.com/questions/306110/new-command-with-an-underscore
    Therefore, I remove all spaces from the inference rule name.

    Args:
        query_time_dict:
        derivation_id: numeric identifier of the derivation
    Returns:
        tex_filename: pass back filename without extension because bibtex cannot handle .tex
    Raises:

    >>> path_to_tex_file = "/home/appuser/app/static/"  # must end with /
    >>> generate_tex_for_derivation("000001")
    """

    trace_id = str(random.randint(1000000, 9999999))
    print("[TRACE] func: app/to_add_derivation start " + trace_id)

    tex_filename = derivation_id

    compute.remove_file_debris(
        [path_to_tex_file, "./"], [tex_filename], ["tex", "log", "pdf", "aux"]
    )

    with graphDB_Driver.session() as session:
        query_start_time = time.time()
        derivation_dict = session.read_transaction(
            neo4j_query.get_node_properties, "derivation", derivation_id
        )
    print("latex/generate_tex_file_for_derivation: derivation_dict=", derivation_dict)

    with graphDB_Driver.session() as session:
        query_start_time = time.time()
        list_of_step_dicts_in_this_derivation = session.read_transaction(
            neo4j_query.get_list_of_step_dicts_in_this_derivation, derivation_id
        )

    with graphDB_Driver.session() as session:
        query_start_time = time.time()
        list_of_sequence_values = session.read_transaction(
            neo4j_query.get_list_of_sequence_values_for_derivation_id, derivation_id
        )
    print(
        "latex/generate_tex_file_for_derivation: list_of_sequence_values=",
        list_of_sequence_values,
    )

    with open(tex_filename + ".tex", "w") as lat_file:
        lat_file.write(
            "% this tex file was generated by the Physics Derivation Graph \n"
        )
        lat_file.write("\\documentclass[12pt]{article}\n")  # article or report
        #        lat_file.write('\\thispagestyle{empty}\n')
        lat_file.write(
            "\\usepackage{amsmath,amssymb,amsfonts}\n"
        )  # https://tex.stackexchange.com/questions/32100/what-does-each-ams-package-do
        lat_file.write(
            "\\usepackage[dvipdfmx,colorlinks=true,pdfkeywords={physics derivation graph}]{hyperref}\n"
        )
        lat_file.write("\\usepackage{graphicx} % for including PNG files\n")
        # lat_file.write("\\newcommand{\\when}[1]{{\\rm \\ when\\ }#1}\n")
        # lat_file.write("\\newcommand{\\bra}[1]{\\langle #1 |}\n")
        # lat_file.write("\\newcommand{\\ket}[1]{| #1\\rangle}\n")
        # lat_file.write("\\newcommand{\\op}[1]{\\hat{#1}}\n")
        # lat_file.write("\\newcommand{\\braket}[2]{\\langle #1 | #2 \\rangle}\n")
        # lat_file.write(
        #    "\\newcommand{\\rowCovariantColumnContravariant}[3]{#1_{#2}^{\\ \\ #3}} % left-bottom, right-upper\n"
        # )
        # lat_file.write(
        #    "\\newcommand{\\rowContravariantColumnCovariant}[3]{#1^{#2}_{\\ \\ #3}} % left-upper, right-bottom\n"
        # )

        with graphDB_Driver.session() as session:
            query_start_time = time.time()
            list_of_inference_rule_dicts = session.read_transaction(
                neo4j_query.get_list_node_dicts_of_type, "inference_rule"
            )

        # first, write the inference rules as newcommand at top of .tex file
        lat_file.write("% inference rules as newcommand for use in the body\n")
        for infrule_dict in list_of_inference_rule_dicts:
            number_of_args = (
                infrule_dict["number_of_feeds"]
                + infrule_dict["number_of_inputs"]
                + infrule_dict["number_of_outputs"]
            )
            # https://en.wikibooks.org/wiki/LaTeX/Macros#New_commands
            if number_of_args < 10:
                lat_file.write(
                    "\\newcommand\\"
                    + "".join(
                        filter(str.isalpha, infrule_dict["name_latex"])
                    )  # digits cannot be used to name macros. FAULT EXPECTED: This filtering will create a collision if the only characters distinguishing infrules is a digit
                    + "["
                    + str(  # https://tex.stackexchange.com/questions/306110/new-command-with-an-underscore
                        number_of_args  # macros are limited to 9 inputs;
                    )
                    + "]{"
                    + infrule_dict["latex"]
                    + "}\n"
                )
            else:  # 10 or more args; see https://www.texfaq.org/FAQ-moren9
                lat_file.write(
                    "\\newcommand\\"
                    + "".join(filter(str.isalpha, infrule_dict["name_latex"]))
                    + "[9]{"
                    + "\\def\\ArgOne{{#1}}\n\\def\\ArgTwo{{#2}}\n\\def\\ArgThree{{#3}}\n\\def\\ArgFour{{#4}}\n\\def\\ArgFive{{#5}}\n"
                    + "\\def\\ArgSix{{#6}}\n\\def\\ArgSeven{{#7}}\n\\def\\ArgEight{{#8}}\n\\def\\ArgNine{{#9}}\n\\"
                    + "".join(filter(str.isalpha, infrule_dict["name_latex"]))
                    + "Relay\n"
                    + "}\n"
                )
                lat_file.write(
                    "\\newcommand\\"
                    + "".join(filter(str.isalpha, infrule_dict["name_latex"]))
                    + "Relay["
                    + str(number_of_args - 9)
                    + "]{"
                    + infrule_dict["latex"]
                    .replace("#1", "ArgOne")
                    .replace("#2", "ArgTwo")
                    .replace("#3", "ArgThree")
                    .replace("#4", "ArgFour")
                    .replace("#5", "ArgFive")
                    .replace("#6", "ArgSix")
                    .replace("#7", "ArgSeven")
                    .replace("#8", "ArgEight")
                    .replace("#9", "ArgNine")
                    .replace("#10", "#1")
                    .replace("#11", "#2")
                    .replace("#12", "#3")
                    .replace("#13", "#4")
                    .replace("#14", "#5")
                    + "}\n"
                )

        lat_file.write("\\title{" + str(derivation_dict["name_latex"]) + "}\n")
        lat_file.write("\\date{\\today}\n")
        lat_file.write("\\author{" + str(derivation_dict["author_name_latex"]) + "}\n")
        lat_file.write("\\setlength{\\topmargin}{-.5in}\n")
        lat_file.write("\\setlength{\\textheight}{9in}\n")
        lat_file.write("\\setlength{\\oddsidemargin}{0in}\n")
        lat_file.write("\\setlength{\\textwidth}{6.5in}\n")

        lat_file.write("\\begin{document}\n")
        lat_file.write("\\maketitle\n")

        lat_file.write("\\begin{abstract}\n")
        lat_file.write(
            "Generated by the \\href{http://derivationmap.net/}{Physics Derivation Graph}.\n"
        )
        if len(derivation_dict["abstract_latex"]) > 0:
            # fixed bug https://github.com/allofphysicsgraph/proofofconcept/issues/249
            # safe_string = dat["derivations"][deriv_id]["notes"]
            #                lat_file.write(safe_string + "\n")
            lat_file.write(derivation_dict["abstract_latex"] + "\n")
        lat_file.write("\\end{abstract}\n")

        for linear_indx in list_of_sequence_values:
            # print("linear_indx=", linear_indx)
            for step_dict in list_of_step_dicts_in_this_derivation:
                # print("step_dict=", step_dict)
                if step_dict["sequence_index"] == linear_indx:
                    if "image" in step_dict.keys():
                        lat_file.write("\\begin{center}\n")
                        lat_file.write("\\begin{figure}\n")
                        #        shutil.copy(
                        #            "static/diagrams/" + step_dict["image"]["file name"],
                        #        step_dict["image"]["file name"],
                        # )
                        lat_file.write(
                            "\\includegraphics{"
                            + step_dict["image"]["file name"]
                            + "}\n"
                        )
                        lat_file.write(
                            "\\caption{" + step_dict["image"]["caption"] + "}\n"
                        )
                        lat_file.write(
                            "\\label{fig:" + step_dict["image"]["label"] + "}\n"
                        )
                        lat_file.write("\\end{figure}\n")
                        lat_file.write("\\end{center}\n")
                    # using the newcommand, populate the expression identifiers
                    lat_file.write("% step ID = " + step_dict["id"] + "\n")
                    lat_file.write(
                        # digits cannot be used to name macros
                        "\\"
                        + "".join(filter(str.isalpha, step_dict["inference_rule"]))
                    )
                    for expr_local_id in step_dict["feeds"]:
                        #                        lat_file.write("{" + expr_local_id + "}")
                        expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write(
                            "{" + dat["expressions"][expr_global_id]["latex"] + "}"
                        )
                    for expr_local_id in step_dict["inputs"]:
                        # expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write("{" + expr_local_id + "}")
                    for expr_local_id in step_dict["outputs"]:
                        # expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write("{" + expr_local_id + "}")
                    lat_file.write("\n")
                    if len(step_dict["notes"]) > 0:
                        lat_file.write(
                            step_dict["notes"] + "\n"
                        )  # TODO: if the note contains a $ or %, shenanigans arise
                    # write output expressions
                    for expr_local_id in step_dict["outputs"]:
                        expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write("\\begin{equation}\n")
                        lat_file.write(
                            dat["expressions"][expr_global_id]["latex"] + "\n"
                        )
                        lat_file.write("\\label{eq:" + expr_local_id + "}\n")
                        lat_file.write("\\end{equation}\n")

        lat_file.write("\\bibliographystyle{plain}\n")
        lat_file.write("\\bibliography{pdg.bib}\n")
        lat_file.write("\\end{document}\n")
        lat_file.write("% EOF\n")

    shutil.copy(tex_filename + ".tex", path_to_tex_file + tex_filename + ".tex")
    # logger.info("[trace end " + trace_id + "]")
    return tex_filename  # pass back filename without extension because bibtex cannot handle .tex


def FROMv7_NOT_YET_CONVERTED_generate_pdf_for_derivation(
    graphDB_Driver, query_time_dict: dict, derivation_id: str, path_to_pdf: str
) -> str:
    """

    Args:
        deriv_id: numeric identifier of the derivation
        path_to_pdf = "/home/appuser/app/static/"  # must end with /
    Returns:
        pdf_filename + ".pdf":
    Raises:

    >>> generate_pdf_for_derivation("000001", "myemail@address.com","pdg.db")
    """
    trace_id = str(random.randint(1000000, 9999999))
    # logger.info("[trace start " + trace_id + "]")
    # dat = clib.read_db(path_to_db)

    # to isolate the build process, create a temporary folder
    tmp_latex_folder = "tmp_latex_folder_" + str(random.randint(1000000, 9999999))
    tmp_latex_folder_full_path = os.getcwd() + "/" + tmp_latex_folder + "/"
    os.mkdir(tmp_latex_folder_full_path)

    # destination for the PDF once file is built

    pdf_filename = derivation_id

    # no longer necessary since the temporary build folder is empty
    # compute.remove_file_debris([path_to_pdf], [pdf_filename], ["log", "pdf"])

    tex_filename_without_extension = generate_tex_file_for_derivation(
        graphDB_Driver, query_time_dict, derivation_id, path_to_pdf
    )
    shutil.move(tex_filename_without_extension + ".tex", tmp_latex_folder_full_path)

    # copy the current pdg.bib from static to local for use with bibtex when compiling tex to PDF
    # https://docs.python.org/3/library/shutil.html
    shutil.copy("/home/appuser/app/static/pdg.bib", tmp_latex_folder_full_path)
    # shutil.copy("/home/appuser/app/static/pdg.bib", "/home/appuser/app/")

    # images need to be in the temporary folder to compile the .tex to PDF
    # https://docs.python.org/3/library/shutil.html#shutil.copytree
    # shutil.copytree(
    #        "/home/appuser/app/static/diagrams/", tmp_latex_folder_full_path
    # )
    for filename in glob.glob("/home/appuser/app/static/diagrams/*"):
        # logger.info("copied "+filename+" from "+filename+" to "+tmp_latex_folder_full_path)
        shutil.copy(filename, tmp_latex_folder_full_path)

    # TODO: it would be good to check whether \cite appears in the .tex content

    # first of the latex runs
    process = subprocess.run(
        ["latex", "-halt-on-error", tex_filename_without_extension + ".tex"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )
    # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
    latex_stdout = process.stdout.decode("utf-8")
    latex_stderr = process.stderr.decode("utf-8")

    # logger.debug("latex std out: %s", latex_stdout)
    # logger.debug("latex std err: %s", latex_stderr)

    if "Text line contains an invalid character" in latex_stdout:
        # logger.error("no PDF generated - tex contains invalid character")
        raise Exception("no PDF generated - tex contains invalid character")
    if "No pages of output." in latex_stdout:
        # logger.error("no PDF generated - reason unknown")
        raise Exception("no PDF generated - reason unknown")

    # first of two bibtex runs
    process = subprocess.run(
        ["bibtex", tex_filename_without_extension],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )
    # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
    bibtex_stdout = process.stdout.decode("utf-8")
    bibtex_stderr = process.stderr.decode("utf-8")
    # logger.debug("bibtex std out: %s", bibtex_stdout)
    # logger.debug("bibtex std err: %s", bibtex_stderr)

    # second of two bibtex runs
    process = subprocess.run(
        ["bibtex", tex_filename_without_extension],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )
    # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
    bibtex_stdout = process.stdout.decode("utf-8")
    bibtex_stderr = process.stderr.decode("utf-8")
    # logger.debug("bibtex std out: %s", bibtex_stdout)
    # logger.debug("bibtex std err: %s", bibtex_stderr)

    # run latex a second time to enable references to work
    process = subprocess.run(
        ["latex", "-halt-on-error", tex_filename_without_extension + ".tex"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )

    # https://tex.stackexchange.com/questions/204291/bibtex-latex-compiling
    # run latex a third time to enable references to work
    process = subprocess.run(
        ["latex", "-halt-on-error", tex_filename_without_extension + ".tex"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )

    # https://tex.stackexchange.com/questions/73783/dvipdfm-or-dvipdfmx-or-dvipdft
    # TODO: how does dvipdfmx know the name of the .tex input? In the process below only the output filename is specified (!)
    process = subprocess.run(
        ["dvipdfmx", pdf_filename + ".dvi"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )

    dvipdf_stdout = process.stdout.decode("utf-8")
    dvipdf_stderr = process.stderr.decode("utf-8")

    # logger.debug("dvipdf std out: %s", dvipdf_stdout)
    # logger.debug("dvipdf std err: %s", dvipdf_stderr)

    shutil.move(
        tmp_latex_folder_full_path + pdf_filename + ".pdf",
        path_to_pdf + pdf_filename + ".pdf",
    )
    shutil.rmtree(tmp_latex_folder_full_path)
    # return True, pdf_filename + ".pdf"
    # logger.info("[trace end " + trace_id + "]")
    return pdf_filename + ".pdf"


def create_png_from_expression_latex(input_latex_str: str, png_name: str) -> None:
    """
    latex -halt-on-error file.tex
    dvipng file.dvi -T tight -o file.png

    this function relies on latex  being available on the command line
    this function relies on dvipng being available on the command line
    this function assumes generated PNG should be placed in /home/appuser/app/static/

    Args:
        path_to_db: filename of the SQL database containing
                    a JSON entry that returns a nested dictionary
    Returns:
        None

    Raises:

    >>> create_png_from_expression_latex('a \dot b \\nabla', 'a_filename')
    """
    trace_id = str(random.randint(1000000, 9999999))
    logger.info("[trace start " + trace_id + "]")

    destination_folder = "/home/appuser/app/static/"

    #    logger.debug("png_name = %s", png_name)
    #    logger.debug("input latex str = %s", input_latex_str)

    # TODO: I'd like to have the latex build process take place in an isolated directory
    # instead of the /home/appuser/app/ location used now

    tmp_latex_folder = "tmp_latex_folder_" + str(random.randint(1000000, 9999999))
    tmp_latex_folder_full_path = os.getcwd() + "/" + tmp_latex_folder + "/"
    original_dir = os.getcwd()
    os.mkdir(tmp_latex_folder_full_path)
    os.chdir(tmp_latex_folder_full_path)

    tmp_file = "lat"

    logger.debug("latex = " + str(input_latex_str))
    create_tex_file_for_latex_expression(tmp_file, input_latex_str)

    tex_filename_with_hash = png_name + "_" + md5_of_file(tmp_file + ".tex") + ".tex"

    # shutil.move(tmp_file + ".tex", tex_filename_with_hash)
    # logger.debug(str(os.listdir()))

    # only make PNG if .tex did not exist
    if not os.path.exists("/home/appuser/app/static/" + tex_filename_with_hash):
        shutil.copy(tmp_file + ".tex", destination_folder + tex_filename_with_hash)

        process = subprocess.run(
            ["latex", "-halt-on-error", tmp_file + ".tex"],
            stdout=PIPE,
            stderr=PIPE,
            timeout=proc_timeout,
        )
        # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
        latex_stdout = process.stdout.decode("utf-8")
        latex_stderr = process.stderr.decode("utf-8")

        #    logger.debug(str(os.listdir()))

        logger.debug("latex std out:" + str(latex_stdout))
        logger.debug("latex std err:" + str(latex_stderr))

        if "Text line contains an invalid character" in latex_stdout:
            logging.error("tex input contains invalid charcter")
            shutil.copy(destination_folder + "error.png", destination_folder + png_name)
            raise Exception("no png generated due to invalid character in tex input.")
        #    remove_file_debris(["./"], [tmp_file], ["png"])

        # dvipng file.dvi -T tight -o file.png
        process = subprocess.run(
            ["dvipng", tmp_file + ".dvi", "-T", "tight", "-o", tmp_file + ".png"],
            stdout=PIPE,
            stderr=PIPE,
            timeout=proc_timeout,
        )
        # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
        png_stdout = process.stdout.decode("utf-8")
        png_stderr = process.stderr.decode("utf-8")

        if len(png_stdout) > 0:
            if "This is dvipng" not in png_stdout:
                logger.debug("png std out %s", png_stdout)
        if len(png_stderr) > 0:
            logger.debug("png std err %s", png_stderr)

        # logger.debug(str(os.listdir()))

        if "No such file or directory" in png_stderr:
            logging.error("PNG creation failed for %s", png_name)
            shutil.copy(destination_folder + "error.png", destination_folder + png_name)
            # return False, "no PNG created. Check usepackage in latex"
            raise Exception(
                "no PNG created for " + png_name + ". Check 'usepackage' in latex"
            )

        if not (os.path.isfile(tmp_file + ".png")):
            logging.error("PNG creation failed for %s", png_name)

        shutil.move(tmp_file + ".png", destination_folder + png_name + ".png")

    logger.debug(destination_folder + png_name + ".png")

    os.chdir(original_dir)
    shutil.rmtree(tmp_latex_folder_full_path)

    #    if os.path.isfile(destination_folder + png_name):
    # os.remove('/home/appuser/app/static/'+name_of_png)
    #        logger.error("png already exists!")

    # return True, "success"
    logger.info("[trace end " + trace_id + "]")
    return


def create_tex_file_for_latex_expression(tmp_file: str, input_latex_str: str) -> None:
    """

    Args:
        tmp_file:
        input_latex_str
    Returns:
        None

    Raises:

    >>> create_tex_file_for_latex_expression('filename_without_extension', 'a \dot b \\nabla')
    """
    trace_id = str(random.randint(1000000, 9999999))
    # logger.info("[trace start " + trace_id + "]")

    compute.remove_file_debris(["./"], [tmp_file], ["tex"])

    with open(tmp_file + ".tex", "w") as lat_file:
        lat_file.write("\\documentclass[12pt]{article}\n")
        lat_file.write("\\thispagestyle{empty}\n")
        # https://tex.stackexchange.com/questions/73016/how-do-i-install-an-individual-package-on-a-linux-system
        # if "usepackage{braket}" is on and the package is not available, the process pauses while waiting for user input
        # the web interface is not aware of this pause, so the page hangs
        # lat_file.write("\\usepackage{braket}\n")
        lat_file.write(
            "\\usepackage{amsmath}\n"
        )  # https://tex.stackexchange.com/questions/32100/what-does-each-ams-package-do
        # lat_file.write("\\newcommand{\\when}[1]{{\\rm \\ when\\ }#1}\n")
        # lat_file.write("\\newcommand{\\bra}[1]{\\langle #1 |}\n")
        # lat_file.write("\\newcommand{\\ket}[1]{| #1\\rangle}\n")
        # lat_file.write("\\newcommand{\\op}[1]{\\hat{#1}}\n")
        # lat_file.write("\\newcommand{\\braket}[2]{\\langle #1 | #2 \\rangle}\n")
        # lat_file.write(
        #    "\\newcommand{\\rowCovariantColumnContravariant}[3]{#1_{#2}^{\\ \\ #3}} % left-bottom, right-upper\n"
        # )
        # lat_file.write(
        #    "\\newcommand{\\rowContravariantColumnCovariant}[3]{#1^{#2}_{\\ \\ #3}} % left-upper, right-bottom\n"
        # )

        lat_file.write("\\begin{document}\n")
        lat_file.write("\\huge{\n")
        lat_file.write("$" + input_latex_str + "$\n")
        lat_file.write("}\n")
        lat_file.write("\\end{document}\n")
    # logger.debug("wrote tex file")
    # logger.info("[trace end " + trace_id + "]")
    return


def create_derivation_png(deriv_id: str, path_to_db: str) -> str:
    """
    for a clear description of the graphviz language, see
    https://www.graphviz.org/doc/info/lang.html

    Args:
        deriv_id: numeric identifier of the derivation
        path_to_db: filename of the SQL database containing
                    a JSON entry that returns a nested dictionary
    Returns:
        output_filename: name of file produced by graphviz
    Raises:


    >>> create_derivation_png("000001", "pdg.db")
    """
    trace_id = str(random.randint(1000000, 9999999))
    logger.info("[trace start " + trace_id + "]")

    dat = clib.read_db(path_to_db)

    dot_filename = "/home/appuser/app/static/derivation_" + deriv_id + ".dot"
    with open(dot_filename, "w") as file_handle:
        file_handle.write("digraph physicsDerivation { \n")
        file_handle.write("overlap = false;\n")
        file_handle.write(
            'label="derivation: '
            + dat["derivations"][deriv_id]["name"]
            + '\nhttps://derivationmap.net";\n'
        )
        file_handle.write("fontsize=12;\n")

        for step_id, step_dict in dat["derivations"][deriv_id]["steps"].items():
            write_step_to_graphviz_file(deriv_id, step_id, file_handle, path_to_db)

        file_handle.write("}\n")

    # name the PNG file referencing the hash of the .dot so we can detect changes
    output_filename = (
        "derivation_" + deriv_id + "_" + md5_of_file(dot_filename) + ".png"
    )
    # neato -Tpng graphviz.dot > /home/appuser/app/static/graphviz.png
    #    process = Popen(['neato','-Tpng','graphviz.dot','>','/home/appuser/app/static/graphviz.png'], stdout=PIPE, stderr=PIPE)

    # force redraw when updating step
    # a better way would be to check the md5 hash of the .dot file
    if not os.path.exists("/home/appuser/app/static/" + output_filename):
        process = subprocess.run(
            ["neato", "-Tpng", dot_filename, "-o" + output_filename],
            stdout=PIPE,
            stderr=PIPE,
            timeout=proc_timeout,
        )

        neato_stdout = process.stdout.decode("utf-8")
        if len(neato_stdout) > 0:
            logger.debug(neato_stdout)
        neato_stderr = process.stderr.decode("utf-8")
        if len(neato_stderr) > 0:
            logger.debug(neato_stderr)

        shutil.move(output_filename, "/home/appuser/app/static/" + output_filename)
    # return True, "no invalid latex", output_filename
    logger.info("[trace end " + trace_id + "]")
    return output_filename


def create_step_graphviz_png(deriv_id: str, step_id: str, path_to_db: str) -> str:
    """
    for a clear description of the graphviz language, see
    https://www.graphviz.org/doc/info/lang.html

    Args:
        deriv_id: numeric identifier of the derivation
        step_id: numeric identifier of the step within the derivation
        path_to_db: filename of the SQL database containing
                    a JSON entry that returns a nested dictionary
    Returns:
        output_filename: name of file produced by graphviz
    Raises:


    >>> step_dict = {'inf rule':'add X to both sides',
                     'inf rule local ID':'2948592',
                     'inputs':[{'expr local ID':'9428', 'expr ID':'4928923942'}],
                     'feeds':[{'feed local ID':'319', 'feed latex':'k'],
                     'outputs':[{'expr local ID':'3921', 'expr ID':'9499959299'}]}
    >>> create_step_graphviz_png("000001", "1029890", "pdg.db")

    """
    trace_id = str(random.randint(1000000, 9999999))
    logger.info("[trace start " + trace_id + "]")
    dat = clib.read_db(path_to_db)

    dot_filename = "/home/appuser/app/static/graphviz.dot"
    remove_file_debris(["/home/appuser/app/static/"], ["graphviz"], ["dot"])

    with open(dot_filename, "w") as fil:
        file_handle.write("digraph physicsDerivation { \n")
        file_handle.write("overlap = false;\n")
        file_handle.write(
            'label="step '
            + step_id
            + " in "
            + dat["derivations"][deriv_id]["name"]
            + '\nhttps://derivationmap.net";\n'
        )
        file_handle.write("fontsize=12;\n")

        write_step_to_graphviz_file(deriv_id, step_id, file_handle, path_to_db)
        file_handle.write("}\n")

    #    with open(dot_filename,'r') as fil:
    #       logger.debug(file_handle.read())

    output_filename = step_id + ".png"
    logger.debug("output_filename = %s", output_filename)
    remove_file_debris(["./"], ["graphviz"], ["png"])

    # neato -Tpng graphviz.dot > /home/appuser/app/static/graphviz.png
    #    process = Popen(['neato','-Tpng','graphviz.dot','>','/home/appuser/app/static/graphviz.png'], stdout=PIPE, stderr=PIPE)
    if not os.path.exists("/home/appuser/app/static/" + output_filename):
        process = subprocess.run(
            ["neato", "-Tpng", dot_filename, "-o" + output_filename],
            stdout=PIPE,
            stderr=PIPE,
            timeout=proc_timeout,
        )
        neato_stdout = process.stdout.decode("utf-8")
        if len(neato_stdout) > 0:
            logger.debug(neato_stdout)
        neato_stderr = process.stderr.decode("utf-8")
        if len(neato_stderr) > 0:
            logger.debug(neato_stderr)

        shutil.move(output_filename, "/home/appuser/app/static/" + output_filename)
    # return True, "no invalid latex", output_filename
    logger.info("[trace end " + trace_id + "]")
    return output_filename


def write_step_to_graphviz_file(
    deriv_id: str, step_id: str, fil: TextIO, path_to_db: str
) -> None:
    """

    Args:
        deriv_id: numeric identifier of the derivation
        step_id: numeric identifier of the step within the derivation
        fil:
        path_to_db: filename of the SQL database containing
                    a JSON entry that returns a nested dictionary
    Returns:
        None

    Raises:

    >>> fil = open('a_file','r')
    >>> write_step_to_graphviz_file("000001", "1029890", file_handle, "pdg.db")
    """
    trace_id = str(random.randint(1000000, 9999999))
    logger.info("[trace start " + trace_id + "]")

    dat = clib.read_db(path_to_db)

    step_dict = dat["derivations"][deriv_id]["steps"][step_id]
    logger.debug("step_dict = %s", step_dict)
    #  step_dict = {'inf rule': 'begin derivation', 'inputs': [], 'feeds': [], 'outputs': ['526874110']}
    #    for global_id, latex_and_ast_dict in dat["expressions"].items():
    #        logger.debug(
    #            "expr_dict has %s %s",
    #            global_id,
    #            latex_and_ast_dict["latex"],
    #        )

    # inference rule
    png_name = "".join(filter(str.isalnum, step_dict["inf rule"]))
    if not os.path.isfile("/home/appuser/app/static/" + png_name + ".png"):
        create_png_from_latex("\\text{" + step_dict["inf rule"] + "}", png_name)
    file_handle.write(
        step_id
        + ' [shape=invtrapezium, color=blue, label="",image="/home/appuser/app/static/'
        + png_name
        + ".png"
        + '",labelloc=b];\n'
    )

    # input expression
    for expr_local_id in step_dict["inputs"]:
        expr_global_id = dat["expr local to global"][expr_local_id]
        png_name = expr_global_id
        if not os.path.isfile("/home/appuser/app/static/" + png_name + ".png"):
            create_png_from_latex(dat["expressions"][expr_global_id]["latex"], png_name)
        file_handle.write(expr_local_id + " -> " + step_id + ";\n")
        file_handle.write(
            expr_local_id
            + ' [shape=ellipse, color=black,label="",image="/home/appuser/app/static/'
            + png_name
            + ".png"
            + '",labelloc=b];\n'
        )

    # output expressions
    for expr_local_id in step_dict["outputs"]:
        expr_global_id = dat["expr local to global"][expr_local_id]
        png_name = expr_global_id
        if not os.path.isfile("/home/appuser/app/static/" + png_name + ".png"):
            create_png_from_latex(dat["expressions"][expr_global_id]["latex"], png_name)
        file_handle.write(step_id + " -> " + expr_local_id + ";\n")
        file_handle.write(
            expr_local_id
            + ' [shape=ellipse, color=black,label="",image="/home/appuser/app/static/'
            + png_name
            + ".png"
            + '",labelloc=b];\n'
        )

    # feed expressions
    for expr_local_id in step_dict["feeds"]:
        expr_global_id = dat["expr local to global"][expr_local_id]
        png_name = expr_global_id
        if not os.path.isfile("/home/appuser/app/static/" + png_name + ".png"):
            create_png_from_latex(dat["expressions"][expr_global_id]["latex"], png_name)
        file_handle.write(expr_local_id + " -> " + step_id + ";\n")
        file_handle.write(
            expr_local_id
            + ' [shape=box, color=red,label="",image="/home/appuser/app/static/'
            + png_name
            + ".png"
            + '",labelloc=b];\n'
        )

    logger.info("[trace end " + trace_id + "]")
    return
