def make_string_safe_for_latex(unsafe_str: str) -> str:
    """
    latex characters that require an escape for printing:
    # $ % & \ ^ _ { }
    TODO: I'm not escaping all of these

    Args:
        unsafe_str: strings that may cause Latex compilation to fail, e.g., "a_string" or "url#subsection"
    Returns:
        safe_str: a string that latex should be able to print, e.g., "a\_string" or "url\#subsection"
    """
    # some derivation notes have valid underscores, like
    # \cite{yyyy_author}
    # while some underscores are invalid latex, like
    # https://en.wikipedia.org/wiki/Equations_of_motion
    # --> Remove citations
    # problem: using
    # re.sub(r'cite{.*}', '', some_text)
    # on the string
    # some_text = "an example cite{2222_asdf} and http://asdf_fagaaf and cite{9492_942} of http:/ss_asdf and more"
    # is greedy
    # to use a non-greedy search; https://stackoverflow.com/a/2503438/1164295
    # unsafe_str_without_citations = re.sub(r"cite{.*?}", "", unsafe_str)

    # replace the first _ that occurs within citation with another string
    unsafe_str_replaced_cite = re.sub(
        r"cite{(.*?)_(.*?)}", "cite{\\1NONSTANDARDUNDRSCR\\2}", unsafe_str
    )
    # that approach breaks when cite has more than one underscore, for example
    # \cite{yyyy_author1_author2}
    unsafe_str_replaced_cite = re.sub(
        r"cite{(.*?)_(.*?)}", "cite{\\1NONSTANDARDUNDRSCR\\2}", unsafe_str_replaced_cite
    )

    safe_str = unsafe_str_replaced_cite.replace("_", "\_").replace("%", "\%")

    fixed_underscore_str = safe_str.replace("NONSTANDARDUNDRSCR", "_")

    no_hashtag_str = (
        fixed_underscore_str.replace("#", "\#").replace("$", "\$").replace("%", "\%")
    )

    return no_hashtag_str


def FROMv7_NOT_YET_CONVERTED_generate_tex_for_derivation(
    deriv_id: str, user_email: str, path_to_db: str
) -> str:
    """
    In this iteration of the PDG (v7), I allow for inference rule names
    to have spaces. In previous versions, the inference rule names were
    camel case. When I implemented this function, I learned why the
    inference rule names had been camel case: Latex does not like
    newcommand names to have underscore in them; see https://tex.stackexchange.com/questions/306110/new-command-with-an-underscore
    Therefore, I remove all spaces from the inference rule name

    Args:
        deriv_id: numeric identifier of the derivation
        user_email: email address of the content author
        path_to_db: filename of the SQL database containing
                    a JSON entry that returns a nested dictionary
    Returns:
        tex_filename: pass back filename without extension because bibtex cannot handle .tex
    Raises:


    >>> generate_tex_for_derivation("000001", "myemail@address.com","pdg.db")
    """

    trace_id = str(random.randint(1000000, 9999999))
    logger.info("[trace start " + trace_id + "]")
    dat = clib.read_db(path_to_db)

    path_to_tex = "/home/appuser/app/static/"  # must end with /
    tex_filename = deriv_id

    remove_file_debris([path_to_tex, "./"], [tex_filename], ["tex", "log", "pdf"])

    with open(tex_filename + ".tex", "w") as lat_file:
        lat_file.write(
            "% this tex file was generated by the Physics Derivation Graph \n"
        )
        lat_file.write("\\documentclass[12pt]{article}\n")  # article or report
        #        lat_file.write('\\thispagestyle{empty}\n')
        lat_file.write(
            "\\usepackage{amsmath,amssymb,amsfonts}\n"
        )  # https://tex.stackexchange.com/questions/32100/what-does-each-ams-package-do
        lat_file.write(
            "\\usepackage[dvipdfmx,colorlinks=true,pdfkeywords={physics derivation graph}]{hyperref}\n"
        )
        lat_file.write("\\usepackage{graphicx} % for including PNG files\n")
        # lat_file.write("\\newcommand{\\when}[1]{{\\rm \\ when\\ }#1}\n")
        # lat_file.write("\\newcommand{\\bra}[1]{\\langle #1 |}\n")
        # lat_file.write("\\newcommand{\\ket}[1]{| #1\\rangle}\n")
        # lat_file.write("\\newcommand{\\op}[1]{\\hat{#1}}\n")
        # lat_file.write("\\newcommand{\\braket}[2]{\\langle #1 | #2 \\rangle}\n")
        # lat_file.write(
        #    "\\newcommand{\\rowCovariantColumnContravariant}[3]{#1_{#2}^{\\ \\ #3}} % left-bottom, right-upper\n"
        # )
        # lat_file.write(
        #    "\\newcommand{\\rowContravariantColumnCovariant}[3]{#1^{#2}_{\\ \\ #3}} % left-upper, right-bottom\n"
        # )

        # first, write the inference rules as newcommand at top of .tex file
        lat_file.write("% inference rules as newcommand for use in the body\n")
        for infrule_name, infrule_dict in dat["inference rules"].items():
            number_of_args = (
                infrule_dict["number of feeds"]
                + infrule_dict["number of inputs"]
                + infrule_dict["number of outputs"]
            )
            # https://en.wikibooks.org/wiki/LaTeX/Macros#New_commands
            if number_of_args < 10:
                lat_file.write(
                    "\\newcommand\\"
                    + "".join(
                        filter(str.isalpha, infrule_name)
                    )  # digits cannot be used to name macros
                    + "["
                    + str(  # https://tex.stackexchange.com/questions/306110/new-command-with-an-underscore
                        number_of_args  # macros are limited to 9 inputs;
                    )
                    + "]{"
                    + infrule_dict["latex"]
                    + "}\n"
                )
            else:  # 10 or more args; see https://www.texfaq.org/FAQ-moren9
                lat_file.write(
                    "\\newcommand\\"
                    + "".join(filter(str.isalpha, infrule_name))
                    + "[9]{"
                    + "\\def\\ArgOne{{#1}}\n\\def\\ArgTwo{{#2}}\n\\def\\ArgThree{{#3}}\n\\def\\ArgFour{{#4}}\n\\def\\ArgFive{{#5}}\n"
                    + "\\def\\ArgSix{{#6}}\n\\def\\ArgSeven{{#7}}\n\\def\\ArgEight{{#8}}\n\\def\\ArgNine{{#9}}\n\\"
                    + "".join(filter(str.isalpha, infrule_name))
                    + "Relay\n"
                    + "}\n"
                )
                lat_file.write(
                    "\\newcommand\\"
                    + "".join(filter(str.isalpha, infrule_name))
                    + "Relay["
                    + str(number_of_args - 9)
                    + "]{"
                    + infrule_dict["latex"]
                    .replace("#1", "ArgOne")
                    .replace("#2", "ArgTwo")
                    .replace("#3", "ArgThree")
                    .replace("#4", "ArgFour")
                    .replace("#5", "ArgFive")
                    .replace("#6", "ArgSix")
                    .replace("#7", "ArgSeven")
                    .replace("#8", "ArgEight")
                    .replace("#9", "ArgNine")
                    .replace("#10", "#1")
                    .replace("#11", "#2")
                    .replace("#12", "#3")
                    .replace("#13", "#4")
                    .replace("#14", "#5")
                    + "}\n"
                )

        # extract the list of linear index from the derivation
        list_of_linear_index = []
        for step_id, step_dict in dat["derivations"][deriv_id]["steps"].items():
            list_of_linear_index.append(step_dict["linear index"])
        list_of_linear_index.sort()

        lat_file.write(
            "\\title{"
            + make_string_safe_for_latex(dat["derivations"][deriv_id]["name"])
            + "}\n"
        )
        lat_file.write("\\date{\\today}\n")
        lat_file.write("\\author{" + make_string_safe_for_latex(user_email) + "}\n")
        lat_file.write("\\setlength{\\topmargin}{-.5in}\n")
        lat_file.write("\\setlength{\\textheight}{9in}\n")
        lat_file.write("\\setlength{\\oddsidemargin}{0in}\n")
        lat_file.write("\\setlength{\\textwidth}{6.5in}\n")

        lat_file.write("\\begin{document}\n")
        lat_file.write("\\maketitle\n")

        lat_file.write("\\begin{abstract}\n")
        lat_file.write(
            "Generated by the \\href{http://derivationmap.net/}{Physics Derivation Graph}.\n"
        )
        if "notes" in dat["derivations"][deriv_id].keys():
            if len(dat["derivations"][deriv_id]["notes"]) > 0:
                # fixed bug https://github.com/allofphysicsgraph/proofofconcept/issues/249
                safe_string = make_string_safe_for_latex(
                    dat["derivations"][deriv_id]["notes"]
                )
                lat_file.write(safe_string + "\n")
        else:
            logger.warn("notes field should be present in derivation " + deriv_id)
        lat_file.write("\\end{abstract}\n")

        for linear_indx in list_of_linear_index:
            for step_id, step_dict in dat["derivations"][deriv_id]["steps"].items():
                if step_dict["linear index"] == linear_indx:
                    if "image" in step_dict.keys():
                        lat_file.write("\\begin{center}\n")
                        lat_file.write("\\begin{figure}\n")
                        #        shutil.copy(
                        #            "static/diagrams/" + step_dict["image"]["file name"],
                        #        step_dict["image"]["file name"],
                        # )
                        lat_file.write(
                            "\\includegraphics{"
                            + step_dict["image"]["file name"]
                            + "}\n"
                        )
                        lat_file.write(
                            "\\caption{"
                            + make_string_safe_for_latex(step_dict["image"]["caption"])
                            + "}\n"
                        )
                        lat_file.write(
                            "\\label{fig:"
                            + make_string_safe_for_latex(step_dict["image"]["label"])
                            + "}\n"
                        )
                        lat_file.write("\\end{figure}\n")
                        lat_file.write("\\end{center}\n")
                    # using the newcommand, populate the expression identifiers
                    if step_dict["inf rule"] not in dat["inference rules"].keys():
                        logger.error(
                            'inference rule in step is not in dat["inference rules"]: ',
                            step_dict["inf rule"],
                        )
                        raise Exception(
                            'inference rule in step is not in dat["inference rules"]: ',
                            step_dict["inf rule"],
                        )
                    lat_file.write("% step ID = " + step_id + "\n")
                    lat_file.write(
                        # digits cannot be used to name macros
                        "\\"
                        + "".join(filter(str.isalpha, step_dict["inf rule"]))
                    )
                    for expr_local_id in step_dict["feeds"]:
                        #                        lat_file.write("{" + expr_local_id + "}")
                        expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write(
                            "{" + dat["expressions"][expr_global_id]["latex"] + "}"
                        )
                    for expr_local_id in step_dict["inputs"]:
                        # expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write("{" + expr_local_id + "}")
                    for expr_local_id in step_dict["outputs"]:
                        # expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write("{" + expr_local_id + "}")
                    lat_file.write("\n")
                    if len(step_dict["notes"]) > 0:
                        lat_file.write(
                            make_string_safe_for_latex(step_dict["notes"]) + "\n"
                        )  # TODO: if the note contains a $ or %, shenanigans arise
                    # write output expressions
                    for expr_local_id in step_dict["outputs"]:
                        expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write("\\begin{equation}\n")
                        lat_file.write(
                            dat["expressions"][expr_global_id]["latex"] + "\n"
                        )
                        lat_file.write("\\label{eq:" + expr_local_id + "}\n")
                        lat_file.write("\\end{equation}\n")

        lat_file.write("\\bibliographystyle{plain}\n")
        lat_file.write("\\bibliography{pdg.bib}\n")
        lat_file.write("\\end{document}\n")
        lat_file.write("% EOF\n")

    shutil.copy(tex_filename + ".tex", path_to_tex + tex_filename + ".tex")
    logger.info("[trace end " + trace_id + "]")
    return tex_filename  # pass back filename without extension because bibtex cannot handle .tex


def FROMv7_NOT_YET_CONVERTED_generate_pdf_for_derivation(
    deriv_id: str, user_email: str, path_to_db: str
) -> str:
    """

    Args:
        deriv_id: numeric identifier of the derivation
        user_email: email address of the content author
        path_to_db: filename of the SQL database containing
                    a JSON entry that returns a nested dictionary
    Returns:
        pdf_filename + ".pdf":
    Raises:

    >>> generate_pdf_for_derivation("000001", "myemail@address.com","pdg.db")
    """
    trace_id = str(random.randint(1000000, 9999999))
    logger.info("[trace start " + trace_id + "]")
    dat = clib.read_db(path_to_db)

    # to isolate the build process, create a temporary folder
    tmp_latex_folder = "tmp_latex_folder_" + str(random.randint(1000000, 9999999))
    tmp_latex_folder_full_path = os.getcwd() + "/" + tmp_latex_folder + "/"
    os.mkdir(tmp_latex_folder_full_path)

    # destination for the PDF once file is built
    path_to_pdf = "/home/appuser/app/static/"  # must end with /
    pdf_filename = deriv_id

    # no longer necessary since the temporary build folder is empty
    # remove_file_debris([path_to_pdf], [pdf_filename], ["log", "pdf"])

    tex_filename_without_extension = generate_tex_for_derivation(
        deriv_id, user_email, path_to_db
    )
    shutil.move(tex_filename_without_extension + ".tex", tmp_latex_folder_full_path)

    # copy the current pdg.bib from static to local for use with bibtex when compiling tex to PDF
    # https://docs.python.org/3/library/shutil.html
    shutil.copy("/home/appuser/app/static/pdg.bib", tmp_latex_folder_full_path)
    # shutil.copy("/home/appuser/app/static/pdg.bib", "/home/appuser/app/")

    # images need to be in the temporary folder to compile the .tex to PDF
    # https://docs.python.org/3/library/shutil.html#shutil.copytree
    # shutil.copytree(
    #        "/home/appuser/app/static/diagrams/", tmp_latex_folder_full_path
    # )
    for filename in glob.glob("/home/appuser/app/static/diagrams/*"):
        # logger.info("copied "+filename+" from "+filename+" to "+tmp_latex_folder_full_path)
        shutil.copy(filename, tmp_latex_folder_full_path)

    # TODO: it would be good to check whether \cite appears in the .tex content

    # first of the latex runs
    process = subprocess.run(
        ["latex", "-halt-on-error", tex_filename_without_extension + ".tex"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )
    # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
    latex_stdout = process.stdout.decode("utf-8")
    latex_stderr = process.stderr.decode("utf-8")

    logger.debug("latex std out: %s", latex_stdout)
    logger.debug("latex std err: %s", latex_stderr)

    if "Text line contains an invalid character" in latex_stdout:
        logger.error("no PDF generated - tex contains invalid character")
        raise Exception("no PDF generated - tex contains invalid character")
    if "No pages of output." in latex_stdout:
        logger.error("no PDF generated - reason unknown")
        raise Exception("no PDF generated - reason unknown")

    # first of two bibtex runs
    process = subprocess.run(
        ["bibtex", tex_filename_without_extension],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )
    # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
    bibtex_stdout = process.stdout.decode("utf-8")
    bibtex_stderr = process.stderr.decode("utf-8")
    logger.debug("bibtex std out: %s", bibtex_stdout)
    logger.debug("bibtex std err: %s", bibtex_stderr)

    # second of two bibtex runs
    process = subprocess.run(
        ["bibtex", tex_filename_without_extension],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )
    # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
    bibtex_stdout = process.stdout.decode("utf-8")
    bibtex_stderr = process.stderr.decode("utf-8")
    logger.debug("bibtex std out: %s", bibtex_stdout)
    logger.debug("bibtex std err: %s", bibtex_stderr)

    # run latex a second time to enable references to work
    process = subprocess.run(
        ["latex", "-halt-on-error", tex_filename_without_extension + ".tex"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )

    # https://tex.stackexchange.com/questions/204291/bibtex-latex-compiling
    # run latex a third time to enable references to work
    process = subprocess.run(
        ["latex", "-halt-on-error", tex_filename_without_extension + ".tex"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )

    # https://tex.stackexchange.com/questions/73783/dvipdfm-or-dvipdfmx-or-dvipdft
    # TODO: how does dvipdfmx know the name of the .tex input? In the process below only the output filename is specified (!)
    process = subprocess.run(
        ["dvipdfmx", pdf_filename + ".dvi"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )

    dvipdf_stdout = process.stdout.decode("utf-8")
    dvipdf_stderr = process.stderr.decode("utf-8")

    logger.debug("dvipdf std out: %s", dvipdf_stdout)
    logger.debug("dvipdf std err: %s", dvipdf_stderr)

    shutil.move(
        tmp_latex_folder_full_path + pdf_filename + ".pdf",
        path_to_pdf + pdf_filename + ".pdf",
    )
    shutil.rmtree(tmp_latex_folder_full_path)
    # return True, pdf_filename + ".pdf"
    logger.info("[trace end " + trace_id + "]")
    return pdf_filename + ".pdf"


def FROMv7_NOT_YET_CONVERTED_create_tex_file_for_expr(
    tmp_file: str, input_latex_str: str
) -> None:
    """

    Args:
        tmp_file:
        input_latex_str
    Returns:
        None

    Raises:

    >>> create_tex_file_for_expr('filename_without_extension', 'a \dot b \\nabla')
    """
    trace_id = str(random.randint(1000000, 9999999))
    logger.info("[trace start " + trace_id + "]")

    remove_file_debris(["./"], [tmp_file], ["tex"])

    with open(tmp_file + ".tex", "w") as lat_file:
        lat_file.write("\\documentclass[12pt]{article}\n")
        lat_file.write("\\thispagestyle{empty}\n")
        # https://tex.stackexchange.com/questions/73016/how-do-i-install-an-individual-package-on-a-linux-system
        # if "usepackage{braket}" is on and the package is not available, the process pauses while waiting for user input
        # the web interface is not aware of this pause, so the page hangs
        # lat_file.write("\\usepackage{braket}\n")
        lat_file.write(
            "\\usepackage{amsmath}\n"
        )  # https://tex.stackexchange.com/questions/32100/what-does-each-ams-package-do
        # lat_file.write("\\newcommand{\\when}[1]{{\\rm \\ when\\ }#1}\n")
        # lat_file.write("\\newcommand{\\bra}[1]{\\langle #1 |}\n")
        # lat_file.write("\\newcommand{\\ket}[1]{| #1\\rangle}\n")
        # lat_file.write("\\newcommand{\\op}[1]{\\hat{#1}}\n")
        # lat_file.write("\\newcommand{\\braket}[2]{\\langle #1 | #2 \\rangle}\n")
        # lat_file.write(
        #    "\\newcommand{\\rowCovariantColumnContravariant}[3]{#1_{#2}^{\\ \\ #3}} % left-bottom, right-upper\n"
        # )
        # lat_file.write(
        #    "\\newcommand{\\rowContravariantColumnCovariant}[3]{#1^{#2}_{\\ \\ #3}} % left-upper, right-bottom\n"
        # )

        lat_file.write("\\begin{document}\n")
        lat_file.write("\\huge{\n")
        lat_file.write("$" + input_latex_str + "$\n")
        lat_file.write("}\n")
        lat_file.write("\\end{document}\n")
    # logger.debug("wrote tex file")
    logger.info("[trace end " + trace_id + "]")
    return
