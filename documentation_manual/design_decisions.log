
****************************
2024-05-28

design decision: Constrain user input of expressions to separately provide lhs, relation, rhs, when 

For example:
F = m a when v<<c

(Previously (in v7) I accepted arbitrary Latex as input)

****************************
2024-05-28

design decision: force user to see all expressions before adding new

The landing page intentionally does not have links to "create new expression" and "create new symbol" and "create new inference rule.
The user is forced to see all existing symbols (and expressions and inference rules) before creating a new instance.

The same reasoning applies to where "create new symbol" is placed on the page -- at the bottom, which forces the user to scroll past all existing symbols. 
Same for expressions and inference rules.


****************************
2024-05-28

design decision: treat "symbol" as a node type, rather than have separate node types for subcategories like 
"symbol_operation", "symbol_scalar", "symbol_vector", "symbol_matrix", "symbol_quantum_operator"

Each of these subcategories have distinct properties

https://physicsderivationgraph.blogspot.com/2024/05/distinguishing-scalars-vectors-and.html

****************************
2024-05-28

design decision: feed is a distinct node type

in v7 JSON each step has zero or more feeds, and each feed was in the same category as expressions. 

Feeds do not have the same attributes as symbols, nor do feeds have the same attributes as expressions. 
The category of symbols includes operators, scalars, vectors, matrices. 
Feeds can be composed of symbols, e.g., "x/a".
Feeds should not have equality or inequality and cannot be checked for dimensional consistency.

Feeds are specific to a step: "multiply both sides by" with the feed "x/a" used in two different steps refers to distinct feeds. 
However, a step could feature multiple feeds, and each feed has separate properties.


****************************
2024-05-28

design decision: live assessments over caching

I don't care much about performance of page loads since page loads are less than 5 seconds.
Therefore I see no value in caching results.

Also, caching could give a false response if the cache isn't refreshed appropriately.

Live assessments provide immediate indicators of failure (rather than obfuscating).

Caching would be additional complexity for the design and implementation.


****************************
2024-05-28

design decision: validate expressions and steps at page-load time or off-line?

The cost of validating expressions and steps at page-load time is 
longer page-load durations. 

The cost of validating expressions and steps off-line (e.g., at time of entry or modification) is lower certainty that nothing has changed (e.g., to a symbol)

I'm going to do validation at page-load time because validity isn't an intrinsic property of the node.


****************************
2024-05-28

design decision: sequence order number as property of edge or node for steps

Steps in a derivation are ordered. Two options for specifying the order:
* as a property of the edge connected "derivation" node to each "step" node
xor
* as a property of the "step" node
I'm not currently clear which is correct, so I've chosen the edge property.


Sequence order also matters for arguments of an inference rule: there may be multiple input expressions. In this case sequence order must be an edge property since order isn't a property of either the inference rule or the expressions.

Sequence order matters for Abstract Syntax Trees for an expression. For example, 
"integrate <INTEGRAND> from <LOWERBOUND> to <UPPERBOUND> over <DIFFERENTIAL>"
requires a sequence of symbols -- they cannot be unordered. 
Again, in this case case sequence order must be an edge property since order isn't a property of either the expression or the symbol.

Based on the order number being an edge property for the two cases of inference rule and ASTs, I'm going with edge property between derivations and steps.

****************************
2024-05-24

design decision: ordering symbols versus SymPy for new expressions

In v7 JSON the workflow for new expressions is
1) user provides Latex expression
2) user provides SymPy expression
3) user provides symbols

The reason for that order was that the symbol detection was coming from SymPy's parsing of the Latex.

In v8 Neo4j the workflow is
1) user provides Latex expression
2) user provides symbols
3) user provides SymPy expression

The new sequence (symbols from latex-as-string first, then send to sympy) might be 
advantageous: if the symbols are identified first, that might make SymPy's parsing more likely to be right. For example, parsing
```
a = b
```
using SymPy is more likely to succeed than
```
a = r_{\rm Earth}
```
which fails in SymPy. 

****************************
2024-05-24

design decision: creating new expressions - in isolation versus part of derivation

In the v7 JSON implementation, the only way to create a new expression was to have the expression be associated with a specific derivation in a (new) step. The intent of this was to ensure there were no unconnected expressions. As a positive side-effect, associating a new expression with a derivation helped with guessing the symbols.

In the new (as of 2024) v8 Neo4j design, expressions can not be created during the specification of a derivation step. 
Now an expression has to be created prior to being referenced in a step. The value of separating these actions is that the interaction with the user is easier when processing one expression (rather than a bunch concurrently all related to the step).
Two consequences from this approach:
- guessing the symbols lacks context of a derivation
- expressions may be unconnected to a derivation step

Interestingly, in the v7 JSON implementation a user could add new symbols that were not referenced by any expression.

