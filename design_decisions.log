

****************************
2024-05-28

design decision: live assessments over caching

I don't care much about performance of page loads since page loads are less than 5 seconds.
Therefore I see no value in caching results.

Also, caching could give a false response if the cache isn't refreshed appropriately.

Live assessments provide immediate indicators of failure (rather than obfuscating).

Caching would be additional complexity for the design and implementation.


****************************
2024-05-28

design decision: validate expressions and steps at page-load time or off-line?

The cost of validating expressions and steps at page-load time is 
longer page-load durations. 

The cost of validating expressions and steps off-line (e.g., at time of entry or modification) is lower certainty that nothing has changed (e.g., to a symbol)

I'm going to do validation at page-load time because validity isn't an intrinsic property of the node.


****************************
2024-05-28

design decision: sequence order number as property of edge or node for steps

Steps in a derivation are ordered. Two options for specifying the order:
* as a property of the edge connected "derivation" node to each "step" node
xor
* as a property of the "step" node
I'm not currently clear which is correct, so I've chosen the edge property.


Sequence order also matters for arguments of an inference rule: there may be multiple input expressions. In this case sequence order must be an edge property since order isn't a property of either the inference rule or the expressions.

Sequence order matters for Abstract Syntax Trees for an expression. For example, 
"integrate <INTEGRAND> from <LOWERBOUND> to <UPPERBOUND> over <DIFFERENTIAL>"
requires a sequence of symbols -- they cannot be unordered. 
Again, in this case case sequence order must be an edge property since order isn't a property of either the expression or the symbol.

Based on the order number being an edge property for the two cases of inference rule and ASTs, I'm going with edge property between derivations and steps.

****************************
2024-05-24

design decision: ordering symbols versus SymPy for new expressions

In v7 JSON the workflow for new expressions is
1) user provides Latex expression
2) user provides SymPy expression
3) user provides symbols

The reason for that order was that the symbol detection was coming from SymPy's parsing of the Latex.

In v8 Neo4j the workflow is
1) user provides Latex expression
2) user provides symbols
3) user provides SymPy expression

The new sequence (symbols from latex-as-string first, then send to sympy) might be 
advantageous: if the symbols are identified first, that might make SymPy's parsing more likely to be right. For example, parsing
```
a = b
```
using SymPy is more likely to succeed than
```
a = r_{\rm Earth}
```
which fails in SymPy. 

****************************
2024-05-24

design decision: creating new expressions - in isolation versus part of derivation

In the v7 JSON implementation, the only way to create a new expression was to have the expression be associated with a specific derivation in a (new) step. The intent of this was to ensure there were no unconnected expressions. As a positive side-effect, associating a new expression with a derivation helped with guessing the symbols.

In the new (as of 2024) v8 Neo4j design, expressions can not be created during the specification of a derivation step. 
Now an expression has to be created prior to being referenced in a step. The value of separating these actions is that the interaction with the user is easier when processing one expression (rather than a bunch concurrently all related to the step).
Two consequences from this approach:
- guessing the symbols lacks context of a derivation
- expressions may be unconnected to a derivation step

Interestingly, in the v7 JSON implementation a user could add new symbols that were not referenced by any expression.

